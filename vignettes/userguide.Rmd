---
title: "Cardiocyte Guide"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Cardiocyte Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This package contains tools for analyzing data that quantifies a transient. The package was originally created to analyze the contractions and sarcomeres of cardiomyocytes, but can be used on any vector of time series data quantifying a transient. 

Being able to measure and quantify the intensity of cardiomyocyte contraction is very important in developing treatments for cardiovascular diseases that damage cardiac tissue. Cardiomyocyte contraction can be quantified by measuring the flux of Calcium ions across the cell's cytoplasm, or by measuring the intensity of pixel change on a video of beating cardiomyocytes. Cardiomyocyte sarcomere length and spacing can also be analyzed though visual media, though only a single photo is necessary. This R package contains several tools that make analyzing contraction and sarcomere data much more convenient. Because the contraction data (as well as the sarcomere spacing) is a transient (departs from a baseline, then returns to it, and repeats) it can be measured in terms of peaks and/or pulses. This package includes functions that help measure and quantify these peaks and pulses. 

Each of the highlighted circles above represents an ROI (region of interest) for a video of cardiomyocyte calcium pulses. An open-source software called ImageJ then calculates the mean pixel change intensity (inside each ROI) over the course of the video as a vector of time series data quantifying the calcium flux transient. In the examples below, **"ca_flux"** refers to the data set from all of the ROIs, and **"Mean1"** refers to the first ROI, and **"Mean2"** the second ROI, etc. 

Images of cardiomyocyte sarcomeres can also produce a transient. Using a linear ROI, a vector of transient data (this time over distance rather than time) can be generated by ImageJ and analyzed by this package. In the examples below, **"sarc"** refers to the sarcomere data, and **"Y"** refers to the vector of data from the linear ROI. 

```{r setup}
library(cardiocyte)

sarc <- read.csv("sarc.csv", header = TRUE)

```

# Peak metrics

## Identify peaks with `find_peaks()`

this function takes a vector of time series data quantifying a transient, and returns the location where each peak is located. 

```{r}

find_peaks(ca_flux$Mean1)

find_peaks(ca_flux$Mean2)

find_peaks(sarc$Y)
```


## Establish a baseline with `correct_baseline()`

This function corrects any transient deviation from a baseline, i.e. it makes sure every peak of the transient deviates from the same baseline value. The function takes a vector of time series data quantifying a transient. This function is especially useful when plotting a curve, and can be used in combination with the plot_curve() function (as seen in section 3: Plotting)

```{r}
bl_corrected <- correct_baseline(ca_flux$Mean1)

bl_corrected <- correct_baseline(sarc$Y)

```

## Find the height of peaks with `peak_height()`

This function takes a vector of time series data quantifying a transient, and returns the height of each peak.

```{r}
peak_height(ca_flux$Mean1)

peak_height(ca_flux$Mean2)

peak_height(sarc$Y)
```


## Extract curves with `ensemble()`

This function takes a vector of time series data quantifying a transient, and extracts all the curves from the trace data. Each row represents an individual peak. 

```{r}
(dat <- ensemble(ca_flux$Mean1))

dat2 <- ensemble(ca_flux$Mean2)

dat3 <- ensemble(sarc$Y)
```


## Find the widths of pulses with `pulse_widths()`

This function calculates the widths of pulses. It takes data from an ensemble() matrix (as described above), as well as a specified percentile (p) of the max at which to calculate width. 

```{r}
pulse_widths(dat, .9)

pulse_widths(dat2, .9)

pulse_widths(dat, .8)

pulse_widths(dat3, .9)
```


## Find the time it takes to reach a peak with `time_to_peak()`

This function calculates the time that it takes for a pulse to reach its maximum. The function takes a vector of time series data quantifying a transient, and starts calculating time when the value reaches 10% of the peak height. It returns the time calculated for the pulse to go from 10% to maximum peak height. 

```{r}
time_to_peak(ca_flux$Mean1)

time_to_peak(ca_flux$Mean2)

```

## Find the peak as a percent of the baseline with `percent_peak()`

This function divides the locations of each peak by the baseline value at each peak, then multiplies by 100. The function takes takes a vector of time series data quantifying a transient.

```{r}
percent_peak(ca_flux$Mean1)

percent_peak(ca_flux$Mean2)

percent_peak(sarc$Y)
```

## Find peak height as a percent of the baseline with `percent_peak_height()`

This function divides the heights of each peak by the baseline value at each peak, then multiplies by 100. The function takes a vector of time series data quantifying a transient.

```{r}
percent_peak_height(ca_flux$Mean1)

percent_peak_height(ca_flux$Mean2)

percent_peak_height(sarc$Y)
```


## Find pulse velocity with `max_rates()`

This function returns the maximum velocities of each peak on the transient. The function takes a vector of time series data quantifying a transient, and returns both the locations of the maximum up (x.up) and down (x.down) velocities, as well as the values for the maximum up and down velocities. 

```{r, echo = FALSE}
max_rates <- function(x, p = 0, ...) {
  smooth <- smooth.spline(x)
  derivs <- predict(smooth, deriv = 1)


    max.xs <- find_peaks(derivs$y, p=p, ...)
    max.vs <- derivs$y
    max.vs <- max.vs[max.xs]

    min.xs <- find_peaks(-1*derivs$y, p=p, ...)
    min.vs <- -1*derivs$y
    min.vs <- min.vs[min.xs]

  return(list(x.up = max.xs, x.down = min.xs, velocity.up = max.vs, velocity.down = -1*min.vs))
}
```

```{r}
max_rates(ca_flux$Mean1)

```

## Find velocity as a percent of the baseline with `max_rates_baseline()`

This function divides the maximum transient velocities by the baseline value at the point where the transient reaches its maximum velocity. 

```{r}
max_rates_bl(ca_flux$Mean1)

max_rates_bl(ca_flux$Mean2)

max_rates_bl(sarc$Y)
```

## Find velocity as a percent of peak height with `max_rates_ph()`

This function divides the maximum transient velocities by the height of that specific peak. 

```{r}
max_rates_ph(ca_flux$Mean1)

max_rates_ph(ca_flux$Mean2)

```

## Find the area under a transient with `trans_integral()`

This function finds the area under a transient, or the integral. Essentially, it finds the sum of the area under all the peaks. 

```{r}
trans_integral(ca_flux$Mean1)

trans_integral(ca_flux$Mean2)

trans_integral(sarc$Y)
```


## Find the area under each peak with `peak_integrals()`

This function returns the area under every peak in a transient. 

```{r}
peak_integrals(ca_flux$Mean1)

peak_integrals(ca_flux$Mean2)

peak_integrals(sarc$Y)
```


## Smooth messy peaks with `FFT()`

This function uses the Fast Fourier Transform method to smooth messy data. Especially useful for plotting. Data can also be normalized with two different methods. 

```{r}
head(FFT(ca_flux$Mean1, y=40, norm = "baseline"))

head(FFT(ca_flux$Mean2, y=40, norm = "min"))

head(FFT(sarc$Y, y=30))
```

# Plotting

The cardiocyte package provides functionality to plot annotated transients, 
both in their original form and as overlays (ensemble) of all peaks.

## Annotated transients with `plot_curve()`

We can plot the transients with the plot_curve function

```{r}
plot_curve(ca_flux$Mean1)

plot_curve(sarc$Y)
```

The package also implements annotations as ggplot layers so you can chain the 
plots in the usual ggplot fashion:

```{r}
plot_curve(ca_flux$Mean1) +
  geom_vel("up") +
  geom_vel("down") +
  geom_peaks()

```

The effects of baseline correction can then be directly visualized.

```{r}
plot_curve(correct_baseline(ca_flux$Mean1)) +
  geom_vel("up") +
  geom_vel("down") +
  geom_peaks()

```


Finally, the curves can be extracted an overlaid in an ensemble plot together 
with an averaged curve with error bounds.The offset parameter indicates how 
many time points to drop at the start of the acquisition to assist in centering 
the curves in the ensemble window.

```{r}
plot_ensemble(ca_flux$Mean1, offset = 3, norm=FALSE) 
```

To account for bleaching over the time course, the curves can be normalized to 
standardized heights.

```{r}
plot_ensemble(ca_flux$Mean1, offset = 3, norm=TRUE) 
```

If the data is lengthy with many time points, this alternative method for overlaying the peaks may be more useful. 

```{r}
plot_overlay(ca_flux$Mean1)
```

